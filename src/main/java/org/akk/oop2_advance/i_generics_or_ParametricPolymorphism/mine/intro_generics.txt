ğŸ§  1. What Are Generics?
-------------------------------
Generics allow you to create classes, interfaces, and methods that can operate on different data types while maintaining compile-time type safety.
ğŸ”¹ In simple terms:
    Generics mean you can write code once â€” and use it for any type â€” without losing type safety.


âœ… Problem:
    - Any type could be added (no type checking).
    - You could get ClassCastException at runtime.


âœ… Benefits:
    - Type safety (compiler checks type correctness)
    - No need for explicit casting
    - Code reusability



ğŸ§© 2. The Term: Parametric Polymorphism
----------------------------------------------
    - Polymorphism â†’ â€œmany formsâ€ (same code, different behavior)
    - Parametric â†’ using type parameters (like <T>, <E>, <K,V>)

So, Parametric Polymorphism means:
    A method or class can handle values uniformly without depending on their specific types.




ğŸ”¹ 6. Bounded Type Parameters
-----------------------------------
Sometimes you want to restrict the kinds of types that can be used.


ğŸ§© 1. Why We Need Bounded Type Parameters
------------------------------------------
The type parameter T can be any type â€” String, Integer, Car, Employee, etc.
But sometimes you want to restrict what types are allowed.

For example:
    You want only numeric types (Integer, Double, etc.).
    Or, you want to allow Number and its subclasses but not unrelated types like String.
    Thatâ€™s where bounds come in,
        - Upper Bound
        - Lower Bound



ğŸ”¹ 2. Upper Bound (extends)
============================
âœ… Definition:
An upper-bounded type parameter specifies that the type argument must be a specific class or its subclass (or must implement a specific interface).

ğŸ“˜ Syntax:  <T extends ClassName>

Here:
T can be Integer, Float, Double, etc. (because they all extend Number) But not String or Boolean.




ğŸ”¹ Real-world Analogy:
----------------------
If you say: â€œOnly people who are Employees or subtypes of Employee can enter.â€

Thatâ€™s like: <T extends Employee>
Only Employee, Manager extends Employee, or Developer extends Employee are allowed.




ğŸ§© 3. Lower Bound (super)
---------------------------
âœ… Definition:
A lower-bounded type parameter allows the type argument to be a specific class or any of its superclasses.
Used only with wildcards, not with declared type parameters.

ğŸ“˜ Syntax: <? super ClassName>

    Object
       â†‘
    Number
       â†‘
    Integer



ğŸ¯ 5. PECS Rule (Producer Extends, Consumer Super)
========================================================
This is a famous mnemonic from Joshua Blochâ€™s â€œEffective Javaâ€:

Role	            Use	                Meaning
-----------------------------------------------------------
Producer of data	<? extends T>	    You read from it
Consumer of data	<? super T>	        You write to it

Example:
-------
    void copy(List<? extends Number> src, List<? super Number> dest) {
        for (Number n : src)
            dest.add(n);
    }

    * Source (src) produces elements â†’ extends
    * Destination (dest) consumes elements â†’ super




ğŸ”§ 7. When to Use Which?
===============================
Situation	                                            Bound	                            Example
-------------------------------------------------+--------------------------------------+--------------------------
1. You want to read data of a known supertype	            extends	                            List<? extends Number>
2. You want to write data to a generic collection	        super	                            List<? super Integer>
3. You want to restrict generic class to certain types	    extends (in class declaration)	    class Box<T extends Shape>



ğŸ”¹ 10. Limitations of Generics
===========================================
Limitation	                                                Reason
-------------------------------------------------------------------------------------------------
No primitive types (int, double)	                        Generics work with Objects only
No new T()	                                                Type is unknown at runtime
No T[] array creation	                                    Type erasure
No instanceof with parameterized type	                    Type info erased
Cannot overload methods that differ only by type parameter	Type erasure



