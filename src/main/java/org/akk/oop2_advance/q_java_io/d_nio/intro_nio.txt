In Java, NIO stands for New Input/Output (introduced in Java 1.4).
It was designed to solve limitations of the traditional I/O system (java.io).

‚≠ê What is Java NIO?
======================
Java NIO is a modern alternative to traditional blocking I/O.
It supports:
    ‚úî Non-blocking I/O
    ‚úî High-performance data processing
    ‚úî Efficient file and network operations
    ‚úî Event-driven architecture (used in high-load servers)

üîë Key Concepts in Java NIO
===============================
    | Feature       | Java IO               | Java NIO                                  |
    | ------------- | --------------------- | ----------------------------------------- |
    | Mode          | **Stream-based**      | **Buffer-based**                          |
    | Blocking      | **Always blocking**   | **Non-blocking available**                |
    | Data Handling | One-way (read/write)  | Read/Write from **same object**           |
    | Multiplexing  | ‚ùå No                 | ‚úî **Selector** supports multiple channels |
    | Performance   | Slower for large data | Faster, scalable                          |
    | ------------- | --------------------- | ----------------------------------------- |



üß± Core Components of Java NIO
====================================
    | Component        | Role                                               |
    | ---------------- | -------------------------------------------------- |
    |   Channel        | Connection to read/write data (like a pipe)        |
    |   Buffer         | Data container (memory block)                      |
    |   Selector       | Handles multiple channels with a **single thread** |
    |   Path & Files   | Modern file handling utilities                     |
    | ---------------- | -------------------------------------------------- |


‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
    ‚≠ê - 1. CHANNEL
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

    üö¶ What is a Channel in Java NIO?
    --------------------------------------
    A Channel is a bi-directional (read + write) communication interface used for reading and writing data between:
        ‚úî Files
        ‚úî Sockets
        ‚úî Devices (like network connections)

    üìå Unlike InputStream and OutputStream (which are one-way), a Channel can read AND write ‚Äî often at the same time.

    üìå Channels work with Buffers ‚Äî data always goes:
        Channel ‚áÑ Buffer ‚áÑ Application

    üìå Channels are non-blocking & selectable, making them perfect for high-performance servers.


üß± Channel vs Stream ‚Äî Key Differences
=======================================
    | Feature       | Java IO Streams           | Java NIO Channels              |
    | ------------- | ------------------------- | ------------------------------ |
    | Direction     | One-way (read OR write)   | Two-way (read + write)         |
    | Performance   | Blocking                  | Can be non-blocking            |
    | Data Handling | Byte by byte              | Uses Buffers (bulk data)       |
    | Scalable?     | Hard for multiple clients | Designed for scalability       |
    | Integration   | No selectors              | Uses Selector for multiplexing |


üìö Types of Channels in Java NIO
=====================================
    | Channel Type                            | Description                             |
    | --------------------------------------- | --------------------------------------- |
    | `FileChannel`                           | For reading/writing files               |
    | `SocketChannel`                         | TCP client connection                   |
    | `ServerSocketChannel`                   | TCP server socket (listens for clients) |
    | `DatagramChannel`                       | UDP communication                       |
    | `Pipe.SinkChannel / Pipe.SourceChannel` | IPC (thread-to-thread communication)    |
    | `AsynchronousFileChannel`               | Asynchronous file I/O                   |
    | `AsynchronousSocketChannel`             | Async network I/O                       |
    | --------------------------------------- | --------------------------------------- |


üìå How the Channel Works with Buffer
=======================================
Basic data flow:
    int bytesRead = channel.read(buffer);   // Read data into buffer
    buffer.flip();                           // Prepare for read by app
    buffer.get();                            // App reads data
    buffer.clear();                          // Prepare for next read

    ‚û° flip() and clear() are critical for switching buffer modes.


üéõ Channel Modes
=================
    | ------------ | ------------------------------------------- |
    | Mode         | Meaning                                     |
    | ------------ | ------------------------------------------- |
    | Blocking     | Channel waits for operations to finish      |
    | Non-blocking | Channel returns immediately even if no data |
    | ------------ | ------------------------------------------- |



‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
    ‚≠ê - 2. SELECTORS
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

üåü What is a Selector in Java NIO?
==================================
    Selector = a single thread that can watch MANY channels at the same time
    Selector allows one thread to monitor multiple network connections (channels) and know:
        - which one (channel) is ready to read
        - which one (channel) is ready to write
        - which one (channel) is ready to accept new connections
    This is called multiplexing.

    ‚ùå Problem with Traditional IO (Blocking IO)
        Traditional Server Model (Old IO)
            1 client  ‚Üí 1 thread
            1000 clients ‚Üí 1000 threads üò®

        Problems:
            - Too many threads
            - High memory usage
            - Context switching overhead
            - Server crashes under load













